<post title="On Markup">
  <p>The essence and purpose of markup is to bring annotated text into an
  abstract representation, where it can be manipulated through code (Usually
  simple pattern-template macros).</p>

  <p>Lightweight markup languages like Markdown work for simple documents, like
  this README, because they have syntactic sugar for 80% of what one requires
  for documentation. But fall apart when you want to add new features: What can
  I do if I want tables? Or references? Or just a simple macro to reduce
  repetition? Pandoc provides all of those, through non-standard extensions. But
  what if you want to combine those?</p>

  <p>Consider the following hypothetical example in Pandoc Markdown:</p>

  <code>
    ... Most of the information is presented in *Magnetic Monopoles*[preskill]
    and *Magnetic Monopole Searches with AMANDA and other detectors*[lindell]...

    ...

    [^preskill]:
        John Preskill. *[Magnetic Monopoles][http://...]*.

    [^monmass]:
        Matilda Åberg Lindell.
        *[Magnetic Monopole Searches with AMANDA and other detectors][http://...]*.
  </code>

  <p>The pattern is pretty clear: Italicized text followed by a reference. I
  wish I could do this:</p>

  <code>
    defmacro cite(id, text): *$text*[$id]

    ... Most of the information is presented in cite(preskill, Magnetic
    Monopoles) and cite(lindell, Magnetic Monopole Searches with AMANDA and
    other detectors)...
  </code>

  <p>Of course, Markdown is not extensible. Although Pandoc can be extended to
  transform one group of elements into another, <i>adding</i> a new element is
  not exactly easy.</p>

  <p>On the other hand, consider the following XML:</p>

  <code>
    ... Most of the information is presented in <cite id="preskill">Magnetic
    Monopoles</cite> and <cite id="lindell">Magnetic Monopole Searches with
    AMANDA and other detectors</cite>...
  </code>

  <p>And this XSLT:</p>
  
  <code>
    <xsl:template match="cite">
      <!-- Citations -->
      <xsl:variable name="id" select="@id"/>
      *<xsl:apply-templates/>*[<xsl:value-of select="$id"/>]
    </xsl:template>
  </code>

  <p>A macro. This translates the XML to Markdown, so what you'd do is
  preprocess the <ic>.md</ic> files into pure Markdown, so you can enjoy the
  simplicity of Markdown with the benefits of macros.</p>

  <p>But consider another side to this same example: The text of the
  references. They both follow the same pattern: <ic>[author]. [italicized paper
  name in a link]</ic>. Repetition violates DRY and introduces room for
  mistakes. And what about exceptional situations, such as no link being
  provided. What we need is a macro.</p>

  <code>
    <xsl:template match="references">
      <!-- Text of the references -->
      <section id="references">
        <xsl:for-each select="./ref">
          <div class="text">
            <span class="author"><xsl:value-of select="author"/></span>.
            <em><xsl:value-of select="title"/></em>
            <xsl:if test="desc">
              <p class="desc">
                <xsl:value-of select="desc"/>
              </p>
            </xsl:if>
            <xsl:value-of select="link"/>
          </div>
        </xsl:for-each>
      </section>
    </xsl:template>
  </code>

  <p>Now we can write something like this:</p>

  <code>
    <references>
      <ref id="preskill">
        <link>http://www.theory.caltech.edu/~preskill/pubs/preskill-1984-monopoles.pdf</link>
        <title>Magnetic Monopoles</title>
        <author>John Preskill</author>
      </ref>
      <ref id="lindell">
        <title>Magnetic Monopole Searches with AMANDA and other detectors</title>
        <author>Matilda Åberg Lindell</author>
        <link>http://www.diva-portal.org/smash/get/diva2:320548/FULLTEXT02</link>
        <desc>
          The author remarks that "[Monopoles] could never be produced in any
          man-made accelerator, existing or conceivable".
        </desc>
      </ref>
    </references>
  </code>

  <p>Automatic. Structured. <i>Autistic</i>.</p>

  <p>What if you want to include files? Pandoc has a simple extension that lets
  you do this, but what if you want to add a start-end range? For example, let's
  say you're writing a blog post describing some code, and you keep the code in
  a file (Where it can be run and tested) and include ranged snippets in your
  post. You'd need to modify the extension, which requires some knowledge of
  Haskell, or filtering the raw JSON.</p>

  <p>Or, you can do this (Which only works with XSLT 2.0):</p>

  <code>
    <xsl:template match="include">
      <xsl:variable name="uri" select="@uri"/>
      <xsl:variable name="start" select="number(@start)"/>
      <xsl:variable name="end" select="number(@end)-1"/>
      <xsl:variable name="text" select="tokenize(unparsed-text($uri, 'utf-8'), '\n')"/>
      <xsl:variable name="subseq" select="subsequence($text, $start, $end)"/>
      <pre class="included">
        <xsl:value-of select="string-join($subseq, '&#10;')"/>
      </pre>
    </xsl:template>
  </code>

  <p>Let's go further. You're writing a personal website -- such as this one --
  using Markdown and Pandoc. You have a simple Makefile that runs the Markdown
  files through Pandoc, but you don't want all files to be treated equally:
  Files in the `osts/` folder are converted to HTML with the template for posts,
  files in `slideshows/` are converted using a template for reveal.js
  slideshows. You could do this by separating by files into folders, and telling
  Make to search for different files in different places. Or, you could have a
  root XML element that determines what template will be used, and write the
  templates along with the XSLT. Like this: </p>

  <code>
    <post title="Why XML is horrible and we should all be using Lisp">
      First, S-expressions are more compact than...
    </post>
  </code>

  <p>After doing all this, what <i>exactly</i> is left for Markdown? Replacing
  <strike>hashes</strike> <strike>octothorpes</strike> <strike>pounds</strike>
  number signs with header tags isn't really problematic. I've come up with just
  two items.</p>

  <ul>
    <li>Smart typography: Replacing double dashes with en dashes, smart quotes,
    et cetera.</li>
    <li>I don't want to put `p`s around every paragraph.</li>
  </ul>

  <p>The former is actually two things: Replacing dashes and ellipses with their
  proper characters is easy. Smart quotes, less so (But still doable). The
  latter is even more problematic.</p>

  <p>Let's start with the simple stuff: Replacing dashes and ellipses. This is
  simple enough: We use the <ic>replace</ic> function for the simple elements
  and the more complex <ic>analyze-string</ic> function for the quotes.</p>

  <code>
    
  </code>
</post>
